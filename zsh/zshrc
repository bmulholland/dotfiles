# History configuration
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

# Append to history file instead of replacing it
setopt APPEND_HISTORY
setopt SHARE_HISTORY          # Share history between sessions
setopt HIST_IGNORE_DUPS       # Don't record duplicates
setopt HIST_FIND_NO_DUPS      # Don't show duplicates in search

# Enable safer command correction (corrects commands, not arguments), but
# disable it inside Cursor/VSC so it doesn't block the AI terminal.
if [[ "$TERM_PROGRAM" != "vscode" ]]; then
  setopt correct
fi

# Cursor's VS Code terminal struggles with pagers and interactivity, so skip
# less/git output there and disable noisy UX extras (completion dots, prompts).
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
  export PAGER=cat
  export GIT_PAGER=cat
  COMPLETION_WAITING_DOTS="false"
else
  COMPLETION_WAITING_DOTS="true"
fi

# Protect sensitive commands from going into history by prefixing a space.
setopt HIST_IGNORE_SPACE

alias asdf="mise" # switched from asdf to mise
alias arst="mise" # support colemak layout

alias be="bundle exec"
alias bi="bundle install"
alias bu="bundle update"

alias gs="git status"
alias gch="git checkout"

alias vim=nvim

upgradeall() {
  brew update && \
  brew upgrade && \
  brew upgrade --cask --greedy && \
  brew cleanup && \
  "$ZSH/tools/upgrade.sh" && \
  mise self-update && \
  mise up --bump && \
  echo 'DONE UPGRADE' && \
  omz reload
}
# Long-running upgrade automation is dangerous inside Cursor's AI terminal,
# so stub it out there while keeping the alias elsewhere.
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
  ua() { echo 'upgradeall disabled inside Cursor' >&2; return 1; }
else
  alias ua="upgradeall"
fi

# https://gist.github.com/hlissner/db74d23fc00bed81ff62
# Guard against missing silver searcher and keep replacements safe.
function ag-replace() {
  if ! command -v ag >/dev/null 2>&1; then
    echo "ag-replace: silver searcher (ag) not installed" >&2
    return 1
  fi
  if (( $# < 2 )); then
    echo "usage: ag-replace <pattern> <replacement>" >&2
    return 1
  fi
  ag -0 -l -- "$1" | xargs -0 sed -Ei.bak -e "s/$1/$2/g"
}

# Search for files then open them in MacVim (vimr), preserving spaces/newlines.
# mapfile + null delimiters stop weird filenames from breaking the command.
function mvag() {
  if ! command -v ag >/dev/null 2>&1 || ! command -v vimr >/dev/null 2>&1; then
    echo "mvag: requires ag and vimr" >&2
    return 1
  fi
  mapfile -d '' -t files < <(ag -0 -l -- "$@") || return
  (( ${#files[@]} )) || return 0
  vimr -n --cur-env "${files[@]}"
}

# Search for files then open them in Neovim using the same null-delimited trick.
function vag() {
  if ! command -v ag >/dev/null 2>&1 || ! command -v nvim >/dev/null 2>&1; then
    echo "vag: requires ag and nvim" >&2
    return 1
  fi
  mapfile -d '' -t files < <(ag -0 -l -- "$@") || return
  (( ${#files[@]} )) || return 0
  nvim -n "${files[@]}"
}

# Shortcuts to jump forward/back a word with Alt+Arrow (ESC+arrow in most terms)
bindkey '^[[1;3C' forward-word
bindkey '^[[1;3D' backward-word

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# Secret environment variables - passwords etc.
if [[ -f ~/.zshrcsecrets ]]; then
  source ~/.zshrcsecrets
fi

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# TODO: Go through these plugins and add commands to Anki so I memorize them
# Syntax highlighting from https://github.com/zdharma/fast-syntax-highlighting
plugins=(macos rails rake rake-fast ruby git git-escape-magic aws colorize common-aliases httpie yarn pnpm mise terraform tmux zsh-autosuggestions fast-syntax-highlighting z bundler)
# Cursor sessions shouldn't run chatty/background plugins, but keep them for
# human terminals.
if [[ "$TERM_PROGRAM" != "vscode" ]]; then
  plugins+=(git-auto-fetch you-should-use command-not-found)
fi

# heroku autocomplete setup (only source when cache file exists)
HEROKU_AC_ZSH_SETUP_PATH=$HOME/Library/Caches/heroku/autocomplete/zsh_setup
if [[ -f $HEROKU_AC_ZSH_SETUP_PATH ]]; then
  source $HEROKU_AC_ZSH_SETUP_PATH
fi

# Path to your oh-my-zsh configuration.
ZSH=$HOME/.oh-my-zsh

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
# ZSH_THEME="wezm" # Disabled for starship

source $ZSH/oh-my-zsh.sh

# Force block cursor in all modes outside Cursor, which owns its caret style, so
# we don't fight the editor over caret appearance.
if [[ "$TERM_PROGRAM" != "vscode" ]]; then
  function zle-line-init zle-keymap-select {
    printf '\e[1 q'
  }
  zle -N zle-line-init
  zle -N zle-keymap-select
fi

# Initialize starship prompt when the binary is installed
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

autoload -U +X bashcompinit && bashcompinit
# Tie terraform completion to whichever terraform binary we find
if command -v terraform >/dev/null 2>&1; then
  complete -o nospace -C "$(command -v terraform)" terraform
fi

# Switch delta (diff viewer) between dark and light mode when dark-notify is
# present. Requires matching config in gitconfig:
# https://github.com/dandavison/delta/issues/447
if command -v dark-notify >/dev/null 2>&1; then
  __delta_dark_mode_preexec_function () {
      export DELTA_FEATURES="$(dark-notify -e)-mode"
  }
  typeset -ag preexec_functions;
  preexec_functions=( __delta_dark_mode_preexec_function ${preexec_functions[@]} )
fi
